> {-# LANGUAGE DeriveDataTypeable #-}

> module Language.Haskell.BiDoNotation.Parse where

> import Text.ParserCombinators.Parsec
> import Text.ParserCombinators.Parsec.Expr
> import qualified Text.ParserCombinators.Parsec.Token as Token
> import Text.ParserCombinators.Parsec.Language
> import Language.Haskell.TH

> import Data.Generics

> type Variable = String
> type HaskExp = String

> data CoBinds = CoBind Variable HaskExp CoBinds | EndExpr HaskExp
>          deriving (Show, Data, Typeable)

> data CoDoBlock = CoDoBlock Variable CoBinds
>          deriving (Show, Data, Typeable)

> parseCoBind :: Parser CoBinds
> parseCoBind = (try (do whiteSpace
>                        bindVar <- identifier
>                        lexeme (string "<-")
>                        exp <- tillEndOfLine
>                        remaining <- parseCoBind
>                        return $ CoBind bindVar exp remaining
>                  )) <|> 
>                 (do exp <- tillEndOfLine
>                     return $ EndExpr exp)
>                    
> parseCoDo :: Parser CoDoBlock
> parseCoDo = do whiteSpace
>                paramVar <- parens (identifier)
>                cobinds <- parseCoBind
>                return $ CoDoBlock paramVar cobinds
>                
> tillEndOfLine = do { eof;
>                      return "" }
>                 <|>
>                 do { c <- anyChar;
>                      if (c=='\n') then return ""
>                        else do cs <- tillEndOfLine
>                                return (c:cs) }
>                         

> lexeme = Token.lexeme lexer
> whiteSpace = Token.whiteSpace lexer
> parens = Token.parens lexer
> identifier = Token.identifier lexer


Lex and parse routines
======================

> lexer :: Token.TokenParser ()
> lexer = haskell

> parseExpr :: Monad m => (Parser a) -> (String, Int, Int) -> String -> m a 
> parseExpr parser (file, line, col) input =
>     case (runParser p () "" input) of
>       Left err  -> fail $ show err
>       Right x   -> return x
>   where
>     p = do { pos <- getPosition;
>              setPosition $
>              (flip setSourceName) file $
>              (flip setSourceLine) line $
>              (flip setSourceColumn) col $ pos;
>              spaces;
>              x <- parser;
>              return x; }


          